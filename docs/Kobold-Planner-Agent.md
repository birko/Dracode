# üìã Kobold Planner - Implementation Planning Agent

## Overview

The Kobold Planner is a specialized AI agent that creates structured implementation plans before Kobold workers execute coding tasks. It bridges the gap between high-level task descriptions and concrete execution steps, enabling better visibility, resumability, and quality in code generation.

**Kobold Planner works automatically** - it's invoked by the DrakeExecutionService before Kobolds start working on tasks.

## Purpose

Before a Kobold begins writing code, the Kobold Planner:
1. **Analyzes the task** - Understands requirements and context
2. **Breaks into steps** - Creates atomic, self-contained implementation steps
3. **Identifies files** - Determines which files to create or modify
4. **Orders dependencies** - Sequences steps so dependencies come first
5. **Enables resumability** - Allows interrupted work to continue from last step

## Architecture

```
Drake detects unassigned task
    ‚Üì
Drake summons Kobold Planner
    ‚Üì
KoboldPlannerAgent analyzes task
    ‚Üì
Calls create_implementation_plan tool
    ‚Üì
Creates KoboldImplementationPlan with steps
    ‚Üì
Plan saved to {project}/workspace/{task-id}-plan.json
    ‚Üì
Kobold assigned with existing plan
    ‚Üì
Kobold executes plan step-by-step
```

## Components

### 1. KoboldPlannerAgent (`Agents/KoboldPlannerAgent.cs`)

Specialized agent that inherits from `Agent` with planning-specific system prompt.

**System Prompt Focus:**
- Breaking tasks into atomic steps
- File organization and structure
- Dependency ordering
- Planning best practices

**Available Tools:**
- `create_implementation_plan` - Creates structured plan with steps

**Usage:**
```csharp
var planner = new KoboldPlannerAgent(
    llmProvider: openAiProvider,
    options: new AgentOptions 
    { 
        WorkingDirectory = "./workspace",
        MaxIterations = 5 
    }
);

// Start planning
await planner.RunAsync($@"Task: {taskDescription}

Create an implementation plan for this task.");
```

### 2. CreateImplementationPlanTool (`Agents/Tools/CreateImplementationPlanTool.cs`)

Tool that captures and structures the implementation plan.

**Input Schema:**
```json
{
  "steps": [
    {
      "title": "Step title (1 line)",
      "description": "Detailed instructions",
      "files_to_create": ["path/to/file.cs"],
      "files_to_modify": ["path/to/existing.cs"]
    }
  ]
}
```

**Output:**
- Confirmation message with step count
- Plan stored in static `_lastPlan` for Drake to retrieve
- Thread-safe with lock mechanism

### 3. KoboldImplementationPlan (`Models/Agents/KoboldImplementationPlan.cs`)

Data model representing the complete implementation plan.

**Properties:**
```csharp
public class KoboldImplementationPlan
{
    public Guid Id { get; set; }                    // Unique plan identifier
    public Guid TaskId { get; set; }                // Associated task ID
    public string TaskDescription { get; set; }     // Original task description
    public List<PlanStep> Steps { get; set; }       // Implementation steps
    public PlanStatus Status { get; set; }          // Planning/Ready/InProgress/Completed/Failed
    public DateTime CreatedAt { get; set; }         // Creation timestamp
    public DateTime? StartedAt { get; set; }        // Execution start time
    public DateTime? CompletedAt { get; set; }      // Completion time
    public int CurrentStepIndex { get; set; }       // Current step being executed
}
```

**PlanStatus Enum:**
- `Planning` - Plan is being generated by Kobold Planner
- `Ready` - Plan complete and ready for Kobold execution
- `InProgress` - Kobold is executing the plan
- `Completed` - All steps finished successfully
- `Failed` - Plan execution failed

### 4. PlanStep (`Models/Agents/PlanStep.cs`)

Individual step within an implementation plan.

**Properties:**
```csharp
public class PlanStep
{
    public int StepNumber { get; set; }             // Sequential step number (1-based)
    public string Title { get; set; }               // Short description
    public string Description { get; set; }         // Detailed instructions
    public List<string> FilesToCreate { get; set; } // Files to create
    public List<string> FilesToModify { get; set; } // Files to modify
    public StepStatus Status { get; set; }          // Status of this step
    public DateTime? StartedAt { get; set; }        // When step execution started
    public DateTime? CompletedAt { get; set; }      // When step completed
    public string? ErrorMessage { get; set; }       // Error message if failed
}
```

**StepStatus Enum:**
- `Pending` - Not yet started
- `InProgress` - Currently being executed
- `Completed` - Successfully finished
- `Failed` - Failed with error
- `Skipped` - Intentionally skipped

## Workflow

### Planning Phase

1. **Drake detects unassigned task** from Wyvern-generated task files
2. **Drake checks configuration** - Is planning enabled? (`Planning.Enabled`)
3. **Drake summons Kobold Planner** using configured provider/model
4. **Kobold Planner analyzes task** - Reads task description and context
5. **Planner calls tool** - Uses `create_implementation_plan` with structured steps
6. **Plan is created** - `KoboldImplementationPlan` with status `Ready`
7. **Plan saved to disk** - `{project}/workspace/{task-id}-plan.json`

### Execution Phase

1. **Kobold assigned to task** - Drake assigns Kobold with task ID
2. **Kobold loads plan** - Reads `{task-id}-plan.json` from disk
3. **Plan status updates** - `Ready` ‚Üí `InProgress`
4. **Step-by-step execution:**
   - Load next pending step
   - Update step status to `InProgress`
   - Execute step instructions
   - Mark step as `Completed` or `Failed`
   - Save progress to disk
   - Continue to next step
5. **Plan completion** - When all steps finished, plan status ‚Üí `Completed`

### Resumption After Interruption

If Kobold execution is interrupted (crash, timeout, manual stop):

1. **Kobold restarted** - Drake summons new Kobold for task
2. **Kobold finds existing plan** - Loads `{task-id}-plan.json`
3. **Determines last completed step** - Checks `CurrentStepIndex`
4. **Resumes from next pending step** - Skips completed steps
5. **Continues execution** - Picks up where it left off

## Configuration

### appsettings.json

```json
{
  "KoboldLair": {
    "Planning": {
      "Enabled": true,
      "PlannerProvider": null,
      "PlannerModel": null,
      "MaxPlanningIterations": 5,
      "SavePlanProgress": true,
      "ResumeFromPlan": true
    }
  }
}
```

### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `Enabled` | bool | true | Enable/disable planning phase |
| `PlannerProvider` | string? | null | Provider for planner (null = use global default) |
| `PlannerModel` | string? | null | Model for planner (null = use provider default) |
| `MaxPlanningIterations` | int | 5 | Max iterations for plan generation |
| `SavePlanProgress` | bool | true | Save progress after each step |
| `ResumeFromPlan` | bool | true | Resume from existing plan if found |

### Per-Project Configuration

In `projects.json`, each project can override planner settings:

```json
{
  "agents": {
    "koboldPlanner": {
      "enabled": true,
      "provider": "claude",
      "model": "claude-3-5-sonnet-latest",
      "maxParallel": 1,
      "timeout": 300
    }
  }
}
```

## Benefits

### 1. Visibility
- See exactly what steps will be performed before execution
- Understand the implementation approach
- Review file changes upfront

### 2. Resumability
- Interrupted executions can continue from last completed step
- No need to restart from scratch
- Progress persisted to disk automatically

### 3. Quality
- Structured approach ensures all aspects are considered
- Dependency ordering prevents errors
- Step-by-step execution allows for incremental validation

### 4. Debugging
- Easier to identify which step caused issues
- Step status tracking shows execution history
- Error messages linked to specific steps

### 5. Parallel Execution
- Multiple Kobolds can execute different steps of the same plan (future enhancement)
- Clear boundaries between steps enable parallelization

## Planning Guidelines

### Step Design Best Practices

**‚úÖ Good Steps:**
- "Create User.cs model with properties: Id, Name, Email"
- "Add authentication middleware in Program.cs"
- "Implement IUserRepository interface with CRUD methods"
- "Create unit tests for UserService.GetUser()"

**‚ùå Bad Steps:**
- "Implement the feature" (too vague)
- "Fix all bugs" (not specific)
- "Set up the project" (too broad)
- "Make it work" (no clear goal)

### File Organization

**Consider:**
- Project structure conventions (Controllers/, Models/, Services/)
- Related files (interface + implementation)
- Test files alongside production code
- Configuration files (appsettings.json)

**Example:**
```
Step 1: Create Models/User.cs
Step 2: Create Interfaces/IUserRepository.cs
Step 3: Create Repositories/UserRepository.cs (implements IUserRepository)
Step 4: Create Services/UserService.cs
Step 5: Create Tests/UserServiceTests.cs
```

### Dependency Ordering

**Rules:**
1. Interfaces before implementations
2. Models before services that use them
3. Base classes before derived classes
4. Dependencies before dependents

**Example:**
```
Step 1: Create ILogger interface           ‚Üê Dependency
Step 2: Create ConsoleLogger (uses ILogger) ‚Üê Dependent
Step 3: Create UserService (uses ILogger)  ‚Üê Also dependent
```

## Status Tracking

See [Plan-Status-Tracking.md](Plan-Status-Tracking.md) for detailed information about:
- Plan status transitions (Planning ‚Üí Ready ‚Üí InProgress ‚Üí Completed/Failed)
- Step status transitions (Pending ‚Üí InProgress ‚Üí Completed/Failed/Skipped)
- When statuses change and what triggers them

## File Storage

Plans are stored as JSON in the project workspace:

```
{ProjectsPath}/
  {project-name}/
    workspace/
      {task-id}-plan.json     # Kobold implementation plan
      ... other generated files ...
```

**Plan File Format:**
```json
{
  "id": "plan-uuid",
  "taskId": "task-uuid",
  "taskDescription": "Original task description",
  "status": "InProgress",
  "currentStepIndex": 2,
  "createdAt": "2026-02-06T10:00:00Z",
  "startedAt": "2026-02-06T10:01:00Z",
  "steps": [
    {
      "stepNumber": 1,
      "title": "Create User model",
      "description": "Create User.cs with Id, Name, Email properties",
      "filesToCreate": ["Models/User.cs"],
      "filesToModify": [],
      "status": "Completed",
      "startedAt": "2026-02-06T10:01:00Z",
      "completedAt": "2026-02-06T10:02:00Z"
    },
    {
      "stepNumber": 2,
      "title": "Create IUserRepository interface",
      "description": "Define CRUD methods for User",
      "filesToCreate": ["Interfaces/IUserRepository.cs"],
      "filesToModify": [],
      "status": "InProgress",
      "startedAt": "2026-02-06T10:02:00Z"
    }
  ]
}
```

## Integration with Drake and Kobold

### Drake's Role

1. **Check planning enabled** - Read `Planning.Enabled` config
2. **Summon Planner** - Create KoboldPlannerAgent if enabled
3. **Retrieve plan** - Get plan from CreateImplementationPlanTool
4. **Save plan** - Write to `{task-id}-plan.json`
5. **Assign Kobold** - Pass task ID (Kobold finds plan automatically)

### Kobold's Role

1. **Load plan** - Read plan via KoboldPlanService
2. **Execute steps** - Process steps sequentially
3. **Update status** - Mark steps as InProgress/Completed/Failed
4. **Save progress** - Write updated plan after each step (if `SavePlanProgress`)
5. **Handle errors** - Mark step as Failed, continue or stop based on config

## KoboldPlanService

**File**: `DraCode.KoboldLair/Services/KoboldPlanService.cs`

### Purpose

Manages persistence and retrieval of Kobold implementation plans with **dual-format storage**:
- **JSON** - Machine-readable format for Kobolds to execute
- **Markdown** - Human-readable format for developers to review

### Key Features

‚úÖ **Human-readable filenames** - Plans stored with descriptive names, not GUIDs  
‚úÖ **Dual persistence** - Automatically saves both JSON and Markdown  
‚úÖ **Plan indexing** - Fast lookup by task ID  
‚úÖ **Organized storage** - All plans in `workspace/kobold-plans/` directory  
‚úÖ **Hash-based uniqueness** - 4-character hash prevents filename collisions  

### File Organization

```
{ProjectOutputPath}/
  workspace/
    kobold-plans/
      plan-index.json                          # Task ID ‚Üí Filename mapping
      frontend-1-create-user-auth-a7f3-plan.json    # Machine-readable
      frontend-1-create-user-auth-a7f3-plan.md      # Human-readable
      backend-2-add-api-endpoints-b2d9-plan.json
      backend-2-add-api-endpoints-b2d9-plan.md
      ...
```

### Filename Generation

Plans are saved with human-readable filenames generated from task descriptions:

**Format**: `{sanitized-description}-{4char-hash}-plan.{ext}`

**Examples**:
- Task: `"[frontend-1] Create user authentication form"`
  ‚Üí `frontend-1-create-user-auth-a7f3-plan.json`
- Task: `"Implement REST API endpoints"`
  ‚Üí `implement-rest-api-endpoints-d8c2-plan.json`
- Task: `"Fix bug in data validation"`
  ‚Üí `fix-bug-in-data-validation-3f91-plan.json`

**Filename Rules**:
- Max 40 characters for description part
- Removes markdown formatting (`**`, `*`, `__`, `_`, `` ` ``)
- Extracts bracket prefixes like `[frontend-1]`
- Removes common prefixes: "Task:", "Implement:", "Create:", etc.
- Converts to lowercase with hyphens
- Adds 4-character MD5 hash for uniqueness

### API Methods

#### SavePlanAsync

Saves a plan to disk in both JSON and Markdown formats.

```csharp
public async Task SavePlanAsync(KoboldImplementationPlan plan)
```

**Actions**:
1. Generate human-readable filename (if not set)
2. Save JSON: `{filename}-plan.json`
3. Save Markdown: `{filename}-plan.md`
4. Update plan index: `plan-index.json`
5. Log success

**Example**:
```csharp
var planService = new KoboldPlanService(projectsPath, logger, projectRepo);
await planService.SavePlanAsync(plan);
// Creates:
//   - frontend-1-create-user-auth-a7f3-plan.json
//   - frontend-1-create-user-auth-a7f3-plan.md
//   - Updates plan-index.json
```

#### LoadPlanAsync

Loads a plan from disk by task ID.

```csharp
public async Task<KoboldImplementationPlan?> LoadPlanAsync(
    string projectId, 
    string taskId)
```

**Process**:
1. Check `plan-index.json` for task ID
2. Get human-readable filename
3. Load JSON file
4. Deserialize and return plan

**Example**:
```csharp
var plan = await planService.LoadPlanAsync(projectId, taskId);
if (plan != null)
{
    Console.WriteLine($"Loaded plan: {plan.TaskDescription}");
    Console.WriteLine($"Steps: {plan.Steps.Count}");
}
```

#### PlanExistsAsync

Checks if a plan exists for a task without loading it.

```csharp
public async Task<bool> PlanExistsAsync(string projectId, string taskId)
```

**Example**:
```csharp
if (await planService.PlanExistsAsync(projectId, taskId))
{
    Console.WriteLine("Plan already exists, loading...");
}
```

#### DeletePlanAsync

Deletes both JSON and Markdown files for a plan.

```csharp
public async Task DeletePlanAsync(string projectId, string taskId)
```

**Actions**:
1. Look up filename in index
2. Delete JSON file
3. Delete Markdown file
4. Remove from index

#### GetPlansForProjectAsync

Retrieves all plans for a project, sorted by last update.

```csharp
public async Task<List<KoboldImplementationPlan>> GetPlansForProjectAsync(
    string projectId)
```

**Returns**: List of plans ordered by `UpdatedAt` descending (newest first)

### Plan Index

**File**: `workspace/kobold-plans/plan-index.json`

Maps task IDs to human-readable filenames for fast lookup:

```json
{
  "task-abc-123-guid": "frontend-1-create-user-auth-a7f3",
  "task-def-456-guid": "backend-2-add-api-endpoints-b2d9",
  "task-ghi-789-guid": "implement-rest-api-endpoints-d8c2"
}
```

**Purpose**: 
- Enables fast plan lookup by task ID
- Survives filename changes
- Single source of truth for task ‚Üí filename mapping

### Markdown Format

The human-readable Markdown format includes:

```markdown
# Implementation Plan: Create user authentication form

**Status**: InProgress  
**Created**: 2026-02-06 10:00:00 UTC  
**Started**: 2026-02-06 10:05:00 UTC  
**Current Step**: 3 / 6

---

## Task Description

Create a user authentication form with email and password fields.
Include validation and error handling.

---

## Implementation Steps

### Step 1: Create User model ‚úÖ Completed

**Status**: Completed  
**Duration**: 2 minutes

**Description**: Create a User model class with Id, Name, and Email properties

**Files to Create**:
- Models/User.cs

**Files to Modify**: (none)

---

### Step 2: Create authentication service ‚úÖ Completed

**Status**: Completed  
**Duration**: 5 minutes

**Description**: Implement IAuthService with login/logout methods

**Files to Create**:
- Services/AuthService.cs

**Files to Modify**:
- Program.cs (register service)

---

### Step 3: Create login form component ‚è≥ In Progress

**Status**: InProgress  
**Started**: 2026-02-06 10:12:00 UTC

**Description**: Create React component with email/password inputs

**Files to Create**:
- components/LoginForm.tsx

**Files to Modify**: (none)

---

### Step 4: Add form validation ‚è∏Ô∏è Pending

**Status**: Pending

**Description**: Add client-side validation for email format and password strength

...
```

**Benefits of Markdown**:
- ‚úÖ **Human-readable** - Easy to review in text editor or VS Code
- ‚úÖ **Progress tracking** - See completed vs pending steps at a glance
- ‚úÖ **Duration info** - Shows how long each step took
- ‚úÖ **File listing** - Clear view of what files are affected
- ‚úÖ **Version control friendly** - Git diffs show progress

### Integration with Kobold

When a Kobold is assigned to a task:

1. **Check for existing plan**:
   ```csharp
   var plan = await planService.LoadPlanAsync(projectId, taskId);
   ```

2. **If plan exists** - Load and resume from last completed step
3. **If no plan** - Kobold Planner creates new plan, saves it
4. **During execution** - Kobold updates plan after each step:
   ```csharp
   step.Status = StepStatus.Completed;
   plan.CurrentStepIndex++;
   await planService.SavePlanAsync(plan);
   ```

5. **On completion** - Final save with `Status = Completed`

### Configuration

No specific configuration needed - KoboldPlanService uses project paths from ProjectRepository.

**Constructor**:
```csharp
public KoboldPlanService(
    string projectsPath,                    // Base projects directory
    ILogger<KoboldPlanService>? logger,     // Optional logger
    ProjectRepository? projectRepository)   // Required for path resolution
```

### Error Handling

**Missing ProjectRepository**:
```
InvalidOperationException: Cannot resolve project output path for project 'abc123': 
ProjectRepository is not configured.
```

**Project not found**:
```
InvalidOperationException: Project 'abc123' not found in repository.
```

**Failed to load plan**:
- Returns `null` instead of throwing
- Logs warning with exception details
- Allows graceful fallback to plan creation

### Performance Considerations

**Index Loading**:
- Plan index loaded once per operation
- Cached in memory during single operation
- Small file (< 1KB for 100 plans)

**Parallel Operations**:
- Safe for multiple Kobolds writing different plans
- Each plan has unique filename
- Index updates are atomic file writes

**Storage Size**:
- JSON plans: ~2-10 KB (depends on step count)
- Markdown plans: ~5-20 KB (more verbose)
- Minimal disk space impact

## Example: Complete Planning Flow

### Input Task
```
Create a simple REST API for managing users with GET, POST, PUT, DELETE endpoints.
Use ASP.NET Core and in-memory storage.
```

### Generated Plan

**Step 1: Create User Model**
- **Description**: Create a User model class with Id, Name, and Email properties
- **Files to Create**: Models/User.cs
- **Files to Modify**: []

**Step 2: Create IUserRepository Interface**
- **Description**: Define interface with methods: GetAll, GetById, Create, Update, Delete
- **Files to Create**: Interfaces/IUserRepository.cs
- **Files to Modify**: []

**Step 3: Implement InMemoryUserRepository**
- **Description**: Create repository implementation using Dictionary<int, User>
- **Files to Create**: Repositories/InMemoryUserRepository.cs
- **Files to Modify**: []

**Step 4: Create UserController**
- **Description**: Create API controller with GET, POST, PUT, DELETE endpoints
- **Files to Create**: Controllers/UserController.cs
- **Files to Modify**: []

**Step 5: Register Services**
- **Description**: Register IUserRepository with dependency injection in Program.cs
- **Files to Create**: []
- **Files to Modify**: Program.cs

**Step 6: Add API Documentation**
- **Description**: Add XML comments and Swagger configuration
- **Files to Create**: []
- **Files to Modify**: Program.cs, Controllers/UserController.cs

## Troubleshooting

### Plan Not Created

**Symptoms:**
- Kobold starts without a plan
- No `{task-id}-plan.json` file exists

**Solutions:**
1. Check `Planning.Enabled` is true in config
2. Verify Kobold Planner has valid provider/model
3. Check Drake logs for planning errors
4. Ensure MaxPlanningIterations > 0

### Plan Execution Stalled

**Symptoms:**
- Kobold stops mid-execution
- Plan status stuck in `InProgress`

**Solutions:**
1. Check Kobold timeout settings
2. Review last step's error message
3. Manually set stuck steps to `Failed` or `Skipped`
4. Restart Kobold (will resume from last completed step)

### Steps Out of Order

**Symptoms:**
- Step failures due to missing dependencies
- Files referenced before creation

**Solutions:**
1. Review plan for correct dependency ordering
2. Regenerate plan with better context
3. Manually reorder steps in plan JSON (not recommended)
4. Improve Kobold Planner's system prompt

## Future Enhancements

- **Parallel step execution** - Execute independent steps concurrently
- **Plan validation** - Verify plan feasibility before execution
- **Plan editing UI** - Allow manual plan modification before execution
- **Step templates** - Reusable templates for common patterns
- **Conditional steps** - Steps that execute based on conditions
- **Plan versioning** - Track plan revisions and changes

## Related Documentation

- [Kobold System](Kobold-System.md) - Worker execution details
- [Plan Status Tracking](Plan-Status-Tracking.md) - Status management
- [Drake Monitoring System](Drake-Monitoring-System.md) - Supervision and orchestration
- [Wyvern Project Analyzer](Wyvern-Project-Analyzer.md) - Task creation
